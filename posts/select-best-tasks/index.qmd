---
title: Notes on Select Best Tasks for Cognitive Sub-Domain
author: Zhang, Liang
date: 2023-11-01
date-modified: last-modified
format:
  html:
    code-fold: true
    toc: true
execute:
  warning: false
crossref:
  fig-title: 图
  fig-prefix: 图
  tbl-title: 表
  tbl-prefix: 表
bibliography: references.bib
---

```{r}
#| label: setup
#| cache: false

devtools::load_all()
# the identifiers are large integers
requireNamespace("bit64")
requireNamespace("parameters")

projects <- targets::tar_config_yaml()
```

# 最佳因子模型

我们采用了基于自助法（bootstrap）的因子聚类方法探索任务的因子归类。不过在开始之前，一些特别类似范式的任务仅保留了一个，如 @tbl-schema-thin，其中`thin`一列为`TRUE`的是被去掉的任务。以下用`all`表示使用全部任务，用`thin`表示去掉类似范式任务的结果。

```{r}
#| label: tbl-schema-thin
#| tbl-cap: 相似任务保留情况

read_tsv("config/games_thin.tsv", show_col_types = FALSE) |>
  filter(!is.na(same_id)) |>
  mutate(thin = if_else(thin, "是", "否")) |>
  select(same_id, 名称 = game_name, 是否去掉 = thin) |>
  arrange(same_id, 是否去掉) |>
  gt::gt(
    groupname_col = "same_id",
    row_group_as_column = TRUE
  ) |>
  gtExtras::gt_highlight_rows(
    rows = 是否去掉 == "是",
    fill = "gray"
  )
```

由于因子个数对于我们的研究很重要，我们尝试了很多传统办法，结果很不稳定：

```{r}
#| label: fig-nfactors
#| fig-cap: 传统方法的因子个数结果
#| fig-subcap:
#|   - 包含全部任务
#|   - 去除同范式任务

targets::tar_read(
  n_factors_test_all,
  store = projects$explore_factors$store
) |>
  plot()

targets::tar_read(
  n_factors_test_thin,
  store = projects$explore_factors$store
) |>
  plot()
```

采用基于自助法的因子聚类方法，结果如 @fig-compare-cluster-factors。

```{r}
#| label: fig-compare-cluster-factors
#| fig-width: 10
#| fig-height: 8
#| fig-cap: Evaluation of clustering results

targets::tar_read(cluster_stats, store = projects$explore_factors$store) |>
  ggplot(aes(n_fact, k, fill = crit)) +
  geom_raster() +
  geom_point(aes(n_fact, nc), color = "white") +
  facet_wrap(~schema) +
  scale_x_continuous(name = "Number of Factors", expand = c(0, 0)) +
  scale_y_continuous(name = "Number of Clusters", expand = c(0, 0)) +
  scale_fill_viridis_c(
    name = "Silhouette Score",
    breaks = scales::breaks_pretty(n = 4)
  ) +
  theme_minimal(base_size = 16) +
  theme(legend.position = "top") +
  coord_fixed()
```

我们将每种因子个数条件的最佳聚类结果进一步用验证性因子分析确定哪个模型最佳。注意，我们可以得到每个任务指标的轮廓系数（silhouette score），并且可以用此系数来确定该任务归入对应类别的可信度。一般而言，轮廓系数大于0.5[^1]时才可靠。同时，为了保证因子分析结果的可比性，我们将轮廓系数不达标的的任务指标的载荷固定为0后做验证性因素分析。注意这样也会导致一些聚类结果中部分因子的所有成分指标载荷为0，从而导致模型不能成功拟合，也说明这种聚类结果的不可靠。

[^1]: 查看[ResearchGate上的一个讨论](https://www.researchgate.net/post/Threshold_silhouette_score_for_cluster_analysis)确定这标准来源。

```{r}
#| label: fig-fitmeas-models
#| fig-cap: 所有聚类模型拟合情况（仅展示成功拟合的模型）
#| fig-subcap:
#|   - Mean Silhouette Score
#|   - BIC
#|   - CFI
#|   - RMSEA

tar_load(
  c(gofs, cluster_stats),
  store = projects$explore_factors$store
)
stats <- cluster_stats |>
  filter(k == nc) |>
  full_join(gofs, by = c("schema", "n_fact"))

measures <- c("crit", "bic", "cfi", "rmsea")
for (measure in measures) {
  p <- stats |>
    filter(!is.na(.data[[measure]])) |>
    ggplot(aes(n_fact, .data[[measure]])) +
    geom_point() +
    geom_line() +
    scale_x_continuous(
      name = "Number of Factors",
      breaks = scales::breaks_width(1)
    ) +
    facet_wrap(~ schema, scales = "free_y") +
    ggpubr::theme_pubclean()
  print(p)
}
```

进一步，根据Vuong [-@vuong1989]提出的比较非嵌套模型的检验，我们也对拟合成功的模型做了两两比较。

```{r}
targets::tar_read(comparison, store = projects$explore_factors$store) |>
  select(left, right, everything()) |>
  arrange(right) |>
  gt::gt(groupname_col = "schema", row_group_as_column = TRUE) |>
  gt::fmt_number(columns = !c(left, right))
```

因此，最终采用`thin`里面最佳聚类结果的模型，其具体结果如 @fig-best-model 。基于此结果我们可以比较确定地指出我们的数据可以很好地拟合一个包含七个因子的模型，根据每一个因子里面包含任务之间的关系，我们给出这些因子的名字见。

```{r}
#| label: fig-best-model
#| column: page
#| fig-width: 10
#| fig-height: 6
#| fig-cap: 最佳模型各因子所含任务指标

targets::tar_read(config_thin_7, store = projects$explore_factors$store) |>
  separate_wider_delim(
    game_index, ".",
    names = c("game_name_abbr", "index_name")
  ) |>
  mutate(
    game_name = pull(
      data.iquizoo::game_info,
      game_name,
      game_name_abbr
    )[game_name_abbr]
  ) |>
  ggplot(aes(label = game_name, size = sil_width, color = sil_width < 0.5)) +
  ggwordcloud::geom_text_wordcloud() +
  scale_color_grey() +
  facet_wrap(~latent) +
  theme_minimal()
```

```{r}
#| label: tbl-dimensions
#| tbl-cap: 各维度命名

dimensions <- read_csv("config/dimensions.csv", show_col_types = FALSE)
dimensions |>
  mutate(factor = str_c("F", cluster), .keep = "unused", .before = 1L) |>
  gt::gt(rowname_col = "factor")
```

# 任务挑选

对于以上的因子聚类结果，采用以下几个方案以寻找优化拟合指标方案：

* `full`：每个因子内部所有任务指标
* `parsimony`: 简化，基于轮廓系数大于0.5的任务指标
  * `good_sil`：仅包含轮廓系数大于0.5的任务指标
  * `good_load`：仅包含因子载荷大于0.4的任务指标（载荷基于`good_sil`，下同）
  * `adjusted`：从`good_sil`结果中去掉`Inh`维度中几个明显不合理任务指标（含两个时间知觉任务、一个数感任务、一个错误记忆任务）
* `superparsimony`：超简化，选用每个维度最好3-4个任务指标
  * `top_sil_3`：仅包含每个维度轮廓系数最大三个任务指标
  * `top_sil_4`：仅包含每个维度轮廓系数最大四个任务指标
  * `top_load_3`：仅包含每个维度因子载荷最大三个任务指标
  * `top_load_4`：仅包含每个维度因子载荷最大四个任务指标

@fig-parsi-models 给出了各种方案不同模型的拟合优度。整体上看，基于载荷或者轮廓系数选出的任务都能得到相对较好的CFI拟合指标（\>0.9）。

```{r}
#| label: fig-parsi-models
#| fig-cap: 不同方案CFI拟合优度

tar_read(gofs, store = projects$confirm_factors$store) |>
  mutate(
    name = factor(name, hypers_config_dims$name),
    group = case_match(
      name,
      c("good_sil", "good_load", "adjusted") ~ "parsimony",
      c("top_sil_3", "top_sil_4") ~ "top_sil",
      c("top_load_3", "top_load_4") ~ "top_load",
      .default = name
    ),
    .after = name
  ) |>
  ggplot(aes(name, cfi, color = theory)) +
  geom_point() +
  geom_line(aes(group = theory)) +
  ggpubr::theme_pubclean() +
  facet_grid(cols = vars(group), space = "free", scales = "free_x") +
  scale_x_discrete(name = NULL)
```

整体上看，包含最完整任务指标的模型为`adjusted`方案。 @tbl-loadings-adjusted 展示了该方案的各任务指标的因子载荷。

```{r}
#| label: tbl-loadings-adjusted
#| tbl-cap: "`adjusted`方案因子载荷"

targets::tar_read(fit_fo_adjusted, store = projects$confirm_factors$store) |>
  parameters::model_parameters(component = "loading") |>
  as_tibble() |>
  separate_wider_delim(
    From, ".",
    names = c("game_name_abbr", "index_name")
  ) |>
  left_join(data.iquizoo::game_info, by = "game_name_abbr") |>
  left_join(
    targets::tar_read(
      test_retest,
      store = projects$prepare_source_data_retest$store
    ) |>
      filter(origin == "rm_out"),
    by = join_by(game_id, index_name)
  ) |>
  mutate(Dimension = as_factor(To)) |>
  select(
    Dimension,
    `Game Name` = game_name,
    `Index Name` = index_name,
    Loading = Coefficient,
    ICC = icc
  ) |>
  arrange(Dimension, desc(Loading)) |>
  gt::gt(
    groupname_col = "Dimension",
    row_group_as_column = TRUE
  )
```

# 能力分估计（因子得分）

```{r}
#| label: fig-cor-fact-scores-among-selection
#| column: page
#| fig-width: 12
#| fig-height: 10
#| fig-cap: 不同任务选择方案的因子得分相关
#| fig-subcap: true

tar_load(scores_factor, store = projects$confirm_factors$store)
factors <- c("g", dimensions$dim_label)
for (factor in factors) {
  p <- scores_factor |>
    filter(theory == "bf") |>
    pivot_wider(
      id_cols = user_id,
      names_from = name,
      values_from = all_of(factor)
    ) |>
    select(!user_id) |>
    GGally::ggpairs() +
    ggtitle(factor)
  print(p)
}
```

@fig-cor-fact-scores-among-theory 表明：bi-factor模型和另两个模型拟合出来的特殊能力分数相关仅为0.5上下，这是因为bi-factor模型从这些特殊能力中去掉了一般能力的影响，而另两个模型则一定程度上混入了一般能力[@murray2013]。而bi-factor模型的这一特性正是我们所需要的。

```{r}
#| label: fig-cor-fact-scores-among-theory
#| fig-width: 6
#| fig-height: 5
#| fig-cap: 不同理论的因子得分相关
#| fig-subcap: true

factors <- c("g", dimensions$dim_label)
for (factor in factors) {
  p <- scores_factor |>
    filter(name == "adjusted") |>
    pivot_wider(
      id_cols = user_id,
      names_from = theory,
      values_from = all_of(factor)
    ) |>
    select(!where(anyNA)) |>
    select(!user_id) |>
    GGally::ggpairs() +
    ggtitle(factor)
  print(p)
}
```

# 短版本

原则：在总时长一样的情况下，如何以最高的准确性测量一般智力和各个子能力维度？

重点比较：

1. 单一较长版本任务
2. 多个较短版本任务
